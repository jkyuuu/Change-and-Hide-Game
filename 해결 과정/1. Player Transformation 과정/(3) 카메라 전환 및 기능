(3) 카메라 전환 및 기능 ( 맨 아래 카메라 부분 전면 수정 )
  
  < 기존 > (변경 전)
  
   - 미리 만들어둔 비활성화 된 3인칭 카메라를 instantiate한 오브젝트 자식으로 가져와서 플레이어 마우스 상하 이동 구현을 해야함.
   - Find 는 성능에 문제가 생길 수 있기에 함수 구현 내에 쓰지 않고 Awake() 라이프사이클에 넣어 오브젝트 활성화 상관없이 스크립트 호출되자마자 3인칭 카메라를 찾을 수 있게 함.
   - 단, 비활성해두었기 때문에 Find로 찾을 수 없어서 빈 오브젝트를 3인칭 카메라 부모로 만들어서 빈 오브젝트의 자식으로 찾을 수 있게 함.
   --> subCamParent = GameObject.Find("Sub Cam Parent").transform;
       subCamera = subCamParent.GetChild(0);
   --> Null 오류가 생기기에 if(subCamera == Null) 이라면 "서브 카메라 없음"을 디버그함.
   
   --> 그 다음, 오브젝트 생성될 때 3인칭 카메라 활성화 시키고 SetParent를 이용해 subCamera 오브젝트가 instantiate된 오브젝트 자식으로 들어가게 함.
   --> localPosition을 생성된 플레이어 오브젝트에서 일정 간격 떨어진 곳으로 이동한 위치로 들어감.
   --> 또한 플레이어 마우스 컨트롤도 CompareTag("Player")가 아니면 컨트롤 되지 않게 함. -> 3인칭 카메라는 캐릭터 기준으로 회전해야 하기 떄문에 기존 1인칭 플레이어만 적용.
   
   <문제>
   A) 3인칭 카메라 전환은 가능하지만 카메라가 플레이어 기준이 아닌 카메라 기준으로 회전하여 회전 시 캐릭터가 앵글을 벗어남.
   - 플레이어 기준으로 3인칭 서브카메라가 회전 할 수 있게 수정해야 함.
   
   <<수정>>
   -> 3인칭 카메라를 instantiate 된 오브젝트 자식으로 들어가게 하지 않고(즉, 카메라를 3인칭 플레이어 자식으로 넣지 않고) 카메라가 플레이어를 따라오도록 설정함.
   -> 카메라 위치는 3인칭 플레이어에서 z축을 바라보는 카메라까지 거리로 한다.
   -> 플레이어의 이동 방향은 카메라가 바라보는 방향을 기준으로 플레이어의 z축, x축 이동이 가능하게 함.
   
        Vector3 zDistance = new Vector3(0f, 0f, distanceZ);
        Vector3 yDistance = new Vector3(0f, distanceY, 0f);
        transform.position = thirdPlayer.transform.position - (transform.rotation * zDistance + yDistance);
   
   B) 위 문제에 이어 3인칭 카메라가 플레이어 기준으로 회전이 가능하다면 이제 카메라가 바라보는 방향대로 플레이어 z방향이 움직여야 한다.
   - 즉, 카메라가 바라보는 방향으로 플레이어가 따라서 회전해야 한다.
    --> transform.LookAt() 이나 rigidbody.MoveRotation() 으로 카메라가 바라보는 방향으로 플레이어 회전을 주었다.
    --> 하지만 이 경우 기존 position에서 rotation 회전 각 까지의 속도가 빨라 회전 시 플레이어가 부드럽게 회전하지 못하는 문제가 발생했다.
    
   *** 해결 : LookAt()과 MoveRotation() 대신 rigidbody.rotation을 Quaternion.Lerp(float a, float b, float t) 로 설정했다.
    --> Lerp() : 회전각 a에서 회전각 b까지 t의 속도로 회전한다.
    
        Vector3 playerToSubcam = playerTransformation.subCamera.transform.forward;
        playerToSubcam.y = 0f;
        Quaternion newRotation = Quaternion.LookRotation(playerToSubcam);
        playerRigidbody.rotation = Quaternion.Lerp(playerRigidbody.rotation, newRotation, Time.deltaTime * rotateSpeed);
        
    - 서브 캠의 앞 방향을 설정하고, 그 앞 방향이 수평선을 바라보도록 y축을 0으로 설정해 바라보는 시점이 위아래로 흔들리지 않게 한다.
    - 앞을 바라보는 방향으로 회전을 newRotation으로 설정.
    - 오브젝트 rigidbody 회전을 Lerp를 이용해 현재 회전각에서 newRotation으로 회전하게 하되, 지정 속도로 회전하도록 설정한다.
   
   C) 3인칭 카메라일 때 플레이어가 회전하지 않고 주변을 관찰 할 수 있도록 설정하기.
    --> Input.GetKey(KeyCode.LeftShift) 일 경우 CancleInvoke()를 이용해 위 B)의 실행 함수 thirdMove를 실행 중단한다. 누르지 않을 경우는 함수 실행.
   
            if(Input.GetKey(KeyCode.LeftShift))
            {
                CancelInvoke("thirdMove");
                Debug.Log("thirMove 함수 중단");
            }
            else
            {
                thirdMove();
            }
            
            
            
   <<< 카메라 부분 전면 수정 >>>

    < 기존 > (위 내용)
    -	main, sub 두 개의 카메라를 이용해 main이 비활성 되면 sub가 활성화 되도록 하는 방식으로 시점 변경 함.

    < 변경 >
    -	하나의 main 카메라를 이용해 시점에 따라 카메라 position 변경함.
    -	camView 클래스를 만들고 이를 카메라에 컴포넌트로 추가한다.
    -	toggleview라는 변수를 생성하고 이것이 1일 때 1인칭 시점, 3일 때 3인칭 시점을 나타냄.
    -	처음 시작시에는 toggleView는 1로 초기화.
    - 1일 때는 1인칭 시점 firstView() 실행.
    -	3일 때는 3인칭 시점 thirdView() 실행.
    -	3인칭 일때는 thirdPersonCam의 FollowCam()도 실행. (이는 기존 방식과 동일)
    -	변신 과정을 거치면서 toggleView의 변경에 따른 시점 전환이 진행됨.
    -	camView.toggleView = 4 - camView.toggleView; -> 이를 이용한 시점 전환.



    if (toggleView == 1)
        {
            firstPlayer = playerTransformation.playerObject;
            FirstView();
        }
        else if (toggleView == 3)
        {
            thirdPlayer = playerTransformation.hitObject;
            if(thirdPlayer != null)
            {
                ThirdView();
            }
        } 

    public void FirstView()
    {
        Vector3 reverseDistance = new Vector3(0.0f, 0.4f, 0.2f);
        Vector3 firstLocation = new Vector3(0f, 1f, 0f);
        transform.position = (firstPlayer.transform.position + firstLocation) + transform.rotation * reverseDistance;
    }
    public void ThirdView()
    {
        Vector3 reverseDistance = new Vector3(0.0f, 0.0f, distance);
        transform.position = thirdPlayer.transform.position - transform.rotation * reverseDistance;
    }
