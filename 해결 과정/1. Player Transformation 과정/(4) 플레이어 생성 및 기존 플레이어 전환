(4) 플레이어 생성 및 기존 플레이어 전환  (1인칭 플레이어 변경 사항 있음)
   
   < 기존 방식 > (아래 변경 사항 있음)
   
   - 특정 키를 눌렀을 때 hitObject 파괴 시키고 SetActive(false) 되어있는 기존 플레이어와 1인칭 카메라로 전환시켜야 함.
   - 기존 플레이어 오브젝트인 playerObject가 비활성이라 그런지 기존 플레이어를 찾지 못하는 오류가 발생. (Null 오류)
   
   --> 기존 플레이어를 빈 오브젝트 자식으로 만들어서 비활성이어도 찾을 수 있도록 Start()에서 Find.Getchild 이용한다.
   --> 기존 플레이어를 활성화 시키고 3인칭 카메라는 비활성화 시키고 원래 위치로 되돌린다.
   --> hitObject 파괴.
   --> state를 State.Ready로.
   
   
   
 <<< 플레이어 부분 전면 수정 >>>
   
   < 기존 > (위 내용)
   -	3인칭 플레이어로 변신 혹은 복귀할 때, 1인칭 플레이어를 활성/비활성
   -	이 과정에서 비활성된 플레이어를 Getchild()를 통해 찾아 활성화 시키고 기존 두 개 카메라를 플레이어에 할당하는 과정에서 할당 오류가 많이 발생.
   
   < 변경 >  (오브젝트 풀 이용)
   -	우선은 카메라를 하나만 사용하기로 했고, 그 과정에서 비활성된 1인칭 플레이어를 찾아 카메라 할당하고 3인칭 변경 시 카메라 이동 과정에서 오류가 발생.
   -	플레이어를 활성, 비활성 시키는 것이 아닌 오브젝트 풀을 이용해서, 시작할 때 풀에 생성하고 Enqueue()한 플레이어 Prefab에 카메라 1인칭 뷰를 할당하고 시작 스폰 위치로 Dequeue().
   -	3인칭 변경 시 1인칭 플레이어는 풀로 Enqueue 함.
   -	다시 1인칭으로 변경 시 플레이어 변경 위치 그대로 Dequeue().
   -	메모리 할당 부분에서도 비활성을 찾아 활성으로 바꾸는 과정을 생성된 프리펩을 돌려쓰는 방법으로 줄일 수 있다고 생각함.
   
   
   
   
   
   -----> 문제점 : 전환 키를 눌렀을 경우 기존 플레이어 오브젝트는 활성화 되나 hitObject가 사라지지 않음. 키 한번 더 눌러야 hitObject가 사라짐.
   
   --> 원인 : 변신한 플레이어의 playerTransformation 스크립트의 hitObject에 오브젝트가 할당되어 있지 않아서 한번 눌렀을 때는 기존 플레이어 오브젝트만 활성화 되고 hitObject는 파괴되지 않음.
              두번째 눌러야 기존 플레이어 스크립트에 hitObject가 할당되어 있기 때문에 그제서야 Destroy(hitObject)가 실행됨.
   *** 해결 : 시작시 플레이어가 thirdPlayerObject라면 hitObject에 this.gameObject를 할당.
   
   
   <enum State의 state 할당 문제 발생>
   --> 변신하거나 돌아올 때 state를 할당하는 것이 아닌 컴포넌트 활성화 시 state 할당. Start() 에서 만약 "Player" 태그라면 State.Ready가 되도록.
   --> 이유는 변신 혹은 돌아오는 함수 실행 시 state 할당하면, 변신할 떄는 새 컴포넌트를 가져와서 초기화되고 돌아갈 떄는 플레이어에서 State.Ready가 아닌 State.Transformation으로 변한 
   상태로 플레이어 오브젝트가 활성화 되기 때문이다.
   
   <새로운 문제점>
   레이 쏴서 클릭시 캐릭터 변경되는데 그 상태에서 마우스와 키보드 이동하지 않고 리턴 키 누르면 같은 위치에서 레이를 계속 맞아서 그런지 클릭 하지 않았는데도 다시 3인칭 캐릭터로 돌아감.
   마우스와 키보드로 일정거리 이동하지 않으면 무한 반복. 기존 플레이어로 돌아가지 않음. 
   
   --> 아직 이유를 모르겠다.
   대략 리턴을 눌렀을 때 레이가 바로 나가면서 Transformation 함수의 if(objectAwareness.rayhit) 구문이 바로 실행 되는 것 같기도 한데
   문제는 이보다 앞선 구문인 클릭도 자동으로 눌린다는 것이다.
   즉, 리턴했을 때 레이를 바로 맞게 되는 상황에서는 마우스 클릭하지 않아도 클릭한 것처럼 Transformation() 이 자동 실행된다.
   
   --> 원인 :
   *** 해결 : 
   
   < 문제 >
   - 기존 플레이어 오브젝트로 활성화 때 1인칭 메인캠의 바라보는 방향이 3인칭 서브캠의 바라보던 방향으로 메인캠(플레이어 오브젝트)이 활성화 되어야 함.
    -> 문제점 : 1인칭 메인캠의 주시 방향이 3인칭으로 바라보던 방향과 상관없이 비활성 되기 전 방향으로 활성화됨. 활성화하면서 3인칭 캠의 방향으로 활성화 되도록 해야함.
    
    *** 해결 : LookAt 함수를 이용해 해결.
    
        var direction = subCamera.transform.forward;
        direction.y = 0;
        playerObject.transform.LookAt(playerObject.transform.position + direction);
        
        --> returnPlayer 함수를 실행했을 때 서브카메라 비활성화되고 1인칭 플레이어와 메인카메라 활성화됨.
        --> 그 후 서브카메라 앞방향을 direction으로 지정해놓고 플레이어는 y 축이 0이어야 하므로 direction.y 를 0으로 설정.
        --> returnPlayer 했을 때 플레이어가 바라보는 방향을 플레이어 위치에서 카메라가 바라보는 앞방향으로 설정.
        --> LookAt() 은 현재 위치 기준이 아닌 절대적인 위치 기준이기 때문에 플레이어 현재 위치에 앞방향을 더해주어야 함.


   <새로운 문제점>
      -	첫번째 변신 할 때 시선 방향이 z축 정면으로 고정됨.
      -	두번째 변신 할 때부터는 1인칭으로 바라보고 있던 시점 아닌 그 전의 1인칭으로 돌아갈 때 transform 시점으로 변신됨.
