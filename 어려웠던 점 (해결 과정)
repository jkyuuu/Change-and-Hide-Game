1. Player Transformation 과정

  (1) 레이를 맞춘 사물 마우스 클릭시 변신 과정
  
   - 레이를 맞은게 true라면 기존 플레이어 오브젝트 파괴시키고 "변신완료" 디버그 출력은 가능했으나, 레이를 맞은 오브젝트를 가져오는 데 실패함.
   - GameObject hitObject = FindObjectOfType<HitObject>().gameObject; 를 이용해 hitObject를 플레이어 오브젝트로 대입시키려 했으나 프리펩 자체를 가져오지 못함.
   
   --> 그래서 Instantiate로 hit에 저장된, LayerMask 가 "ObjectTarget"인 오브젝트를 생성하려 함.
   
   - 문제는 ObjectAwareness 스크립트에서 레이캐스트 hit의 저장 정보를 playerTransform 스크립트로 가져와서 마우스 클릭 시 intantiate 할 것인가이다.
   
   --> 우선, objectAwareness 스크립트에서 Awareness() 함수 실행 시 레이캐스트 hit에 저장된 gameobject를 hitGameobject라는 게임오브젝트로 저장한다.
   --> objectAwareness 스크립트의 hitGameobject를 게임오브젝트로 하여 기존 플레이어의 위치에 instantiate 한다.
   --> 그 다음 기존 플레이어 컴포넌트들을 instantiate 오브젝트에 가져오고 변신하면서 3인칭 카메라로 전환되게 한다.
  
  
  (2) instantiate 된 hitGameobject의 Rotation
  
   - instantiate 된 오브젝트의 Rotation을 고정시키기 위해 RigidbodyConstraints.FreezeRotation 을 이용하여 X축과 Z축을 고정시키려함.   
   - hitObject.Constraints = RigidbodyConstraints.FreezeRotationX;
     hitObject.Constraints = RigidbodyConstraints.FreezeRotationZ;
     
   - 위 처럼 했으나 Z축만 고정이 됨.
   
   --> " | " 를 이용해 해결 가능함을 알게됨.
   --> hitObject.Constraints = RigidbodyConstraints.FreezeRotationX | RigidbodyConstraints.FreezeRotationZ;
  
  
  (3) 카메라 전환
  
   - 미리 만들어둔 비활성화 된 3인칭 카메라를 instantiate한 오브젝트 자식으로 가져와서 플레이어 마우스 상하 이동 구현을 해야함.
   - Find 는 성능에 문제가 생길 수 있기에 함수 구현 내에 쓰지 않고 Awake() 라이프사이클에 넣어 오브젝트 활성화 상관없이 스크립트 호출되자마자 3인칭 카메라를 찾을 수 있게 함.
   - 단, 비활성해두었기 때문에 Find로 찾을 수 없어서 빈 오브젝트를 3인칭 카메라 부모로 만들어서 빈 오브젝트의 자식으로 찾을 수 있게 함.
   --> subCamParent = GameObject.Find("Sub Cam Parent").transform;
       subCamera = subCamParent.GetChild(0);
   --> Null 오류가 생기기에 if(subCamera == Null) 이라면 "서브 카메라 없음"을 디버그함.
   
   --> 그 다음, 오브젝트 생성될 때 3인칭 카메라 활성화 시키고 SetParent를 이용해 subCamera 오브젝트가 instantiate된 오브젝트 자식으로 들어가게 함.
   --> localPosition을 생성된 플레이어 오브젝트에서 일정 간격 떨어진 곳으로 이동한 위치로 들어감.
   --> 또한 플레이어 마우스 컨트롤도 CompareTag("Player")가 아니면 컨트롤 되지 않게 함. -> 3인칭 카메라는 캐릭터 기준으로 회전해야 하기 떄문에 기존 1인칭 플레이어만 적용.
   
   <문제>
   - 3인칭 카메라 전환은 가능하지만 카메라가 플레이어 기준이 아닌 카메라 기준으로 회전하여 회전 시 캐릭터가 앵글을 벗어남.
   - 플레이어 기준으로 3인칭 서브카메라가 회전 할 수 있게 수정해야 함.
   
   <<수정>>
   -> 3인칭 카메라를 instantiate 된 오브젝트 자식으로 들어가게 하지 않고(즉, 카메라를 3인칭 플레이어 자식으로 넣지 않고) 카메라가 플레이어를 따라오도록 설정함.
   -> 카메라 위치는 3인칭 플레이어에서 z축을 바라보는 카메라까지 거리로 한다.
   -> 플레이어의 이동 방향은 카메라가 바라보는 방향을 기준으로 플레이어의 z축, x축 이동이 가능하게 함.
   
        Vector3 zDistance = new Vector3(0f, 0f, distanceZ);
        Vector3 yDistance = new Vector3(0f, distanceY, 0f);
        transform.position = thirdPlayer.transform.position - (transform.rotation * zDistance + yDistance);
   
   - 기존 플레이어 오브젝트로 활성화 때 1인칭 메인캠의 바라보는 방향이 3인칭 서브캠의 바라보던 방향으로 메인캠(플레이어 오브젝트)이 활성화 되어야 함.
    -> 문제점 : 1인칭 메인캠의 주시 방향이 3인칭으로 바라보던 방향과 상관없이 비활성 되기 전 방향으로 활성화됨. 활성화하면서 3인칭 캠의 방향으로 활성화 되도록 해야함.
    
    *** 해결 : LookAt 함수를 이용해 해결.
    
        var direction = subCamera.transform.forward;
        direction.y = 0;
        playerObject.transform.LookAt(playerObject.transform.position + direction);
        
        --> returnPlayer 함수를 실행했을 때 서브카메라 비활성화되고 1인칭 플레이어와 메인카메라 활성화됨.
        --> 그 후 서브카메라 앞방향을 direction으로 지정해놓고 플레이어는 y 축이 0이어야 하므로 direction.y 를 0으로 설정.
        --> returnPlayer 했을 때 플레이어가 바라보는 방향을 플레이어 위치에서 카메라가 바라보는 앞방향으로 설정.
        --> LookAt() 은 현재 위치 기준이 아닌 절대적인 위치 기준이기 때문에 플레이어 현재 위치에 앞방향을 더해주어야 함.
   
  (4) 기존 플레이어로 전환
   
   - 특정 키를 눌렀을 때 hitObject 파괴 시키고 SetActive(false) 되어있는 기존 플레이어와 1인칭 카메라로 전환시켜야 함.
   - 기존 플레이어 오브젝트인 playerObject가 비활성이라 그런지 기존 플레이어를 찾지 못하는 오류가 발생. (Null 오류)
   
   --> 기존 플레이어를 빈 오브젝트 자식으로 만들어서 비활성이어도 찾을 수 있도록 Start()에서 Find.Getchild 이용한다.
   --> 기존 플레이어를 활성화 시키고 3인칭 카메라는 비활성화 시키고 원래 위치로 되돌린다.
   --> hitObject 파괴.
   --> state를 State.Ready로.
   
    -> 문제점 : 전환 키를 눌렀을 경우 기존 플레이어 오브젝트는 활성화 되나 hitObject가 사라지지 않음. 키 한번 더 눌러야 hitObject가 사라짐.
   
   --> 원인 : 변신한 플레이어의 playerTransformation 스크립트의 hitObject에 오브젝트가 할당되어 있지 않아서 한번 눌렀을 때는 기존 플레이어 오브젝트만 활성화 되고 hitObject는 파괴되지 않음.
              두번째 눌러야 기존 플레이어 스크립트에 hitObject가 할당되어 있기 때문에 그제서야 Destroy(hitObject)가 실행됨.
   *** 해결 : 플레이어의 상태가 Transformation이라면 hitObject에 this.gameObject를 할당.
   
   <enum State의 state 할당 문제 발생>
   --> 변신하거나 돌아올 때 state를 할당하는 것이 아닌 컴포넌트 활성화 시 state 할당. Start() 에서 만약 "Player" 태그라면 State.Ready가 되도록.
   --> 이유는 변신 혹은 돌아오는 함수 실행 시 state 할당하면, 변신할 떄는 새 컴포넌트를 가져와서 초기화되고 돌아갈 떄는 플레이어에서 State.Ready가 아닌 State.Transformation으로 변한 
   상태로 플레이어 오브젝트가 활성화 되기 때문이다.
   
   <새로운 문제점>
   레이 쏴서 클릭시 캐릭터 변경되는데 그 상태에서 마우스와 키보드 이동하지 않고 리턴 키 누르면 같은 위치에서 레이를 계속 맞아서 그런지 클릭 하지 않았는데도 다시 3인칭 캐릭터로 돌아감.
   마우스와 키보드로 일정거리 이동하지 않으면 무한 반복. 기존 플레이어로 돌아가지 않음. 
   
   --> 아직 이유를 모르겠다.
   대략 리턴을 눌렀을 때 레이가 바로 나가면서 Transformation 함수의 if(objectAwareness.rayhit) 구문이 바로 실행 되는 것 같기도 한데
   문제는 이보다 앞선 구문인 클릭도 자동으로 눌린다는 것이다.
   즉, 리턴했을 때 레이를 바로 맞게 되는 상황에서는 마우스 클릭하지 않아도 클릭한 것처럼 Transformation() 이 자동 실행된다.
   
   --> 원인 :
   *** 해결 : 
   
  (5) instantiate 오브젝트에 기존 플레이어 스크립트 추가와 스크립트 변수 그대로 가져오기.
  
   - Addcomponent를 이용해 기존 플레이어와 똑같이 스크립트 추가는 가능한데 새 스크립트를 가져오므로 기존 플레이어 스크립트 설정은 초기화가 됨.
   - 초기 기본값 설정을 위해 Start()에서 할당하기.
